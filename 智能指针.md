# unique_ptr

## 1. 独占式拥有

`unique_ptr` 实现独占式拥有或严格拥有概念。

```c++
#include <iostream>
#include <string>
#include <memory>
    
using namespace std;

int main() {
    unique_ptr<std::string> p1(new std::string("unique"));
    unique_ptr<std::string> p2;
    p1 = p2;
    
    return 0;
}

输出结果为：
Desktop % g++ main.cpp -o main -std=c++11
main.cpp:10:8: error: object of type 'unique_ptr<std::string>' 
(aka 'unique_ptr<basic_string<char, char_traits<char>, allocator<char> > >') 
cannot be assigned because its copy assignment operator is implicitly deleted
```

## 2. 临时右值

当程序试图将一个 `unique_ptr` 赋值给另一个时，如果源 `unique_ptr` 是个临时右值，编译器允许这么做。

```c++
#include <iostream>
#include <string>
#include <memory>

using namespace std;

int main() {
    unique_ptr<string> pu;
    pu = unique_ptr<string>(new string("You"));

    return 0;
}
```

## 3. move()

C++ 有一个标准库函数 `std::move()`，让你能够将一个 `unique_ptr` 赋给另一个。

```c++
#include <iostream>
#include <string>
#include <memory>

using namespace std;

int main() {
    unique_ptr<std::string> ps1, ps2;
    ps1 = unique_ptr<std::string>(new std::string("world"));
    ps2 = std::move(ps1);
    ps1 = unique_ptr<std::string>(new std::string("hello"));
    cout << "ps1: " << *ps1 << endl;
    cout << "ps2: " << *ps2 << endl;

    return 0;
}

输出结果为：
Desktop % ./main              
ps1: hello
ps2: world
```

## 4. release()

调用 `release()` 会切断 `unique_ptr` 和它原来管理的对象的联系。
`release()` 返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。

> `release()` 之后返回裸指针。

```c++
#include <iostream>
#include <string>
#include <memory>

using namespace std;

int main() {
    unique_ptr<std::string> ps1, ps2;
    ps1 = unique_ptr<std::string>(new std::string("hello"));
    // ps2 = ps1.release(); // 编译不通过
    std::string * ptr = ps1.release();
    cout << "ps1: " << ps1 << endl;
    cout << "ptr: " << *ptr << endl;

    return 0;
}

输出结果为：
hupeidong@ZBMac-C02F31WYM Desktop % ./main              
ps1: 0x0
ptr: hello
```

# shared_ptr

## 1. 基本方式

```c++
std::shared_ptr<TestClass> p(new TestClass("hello world", 123));
```

这句话调用了两次内存管理器：
1. 创建 TestClass 实例
2. 创建引用计数对象

## 2. make_shared方式

```c++
std::shared_ptr<TestClass> p = std::make_shared<TestClass>("hello world", 123);
```

### 2.1 缺点-低效率

```c++
void fiddle(std::shared_ptr<Foo> f);

shared_ptr<Foo> myFoo = make_shared<Foo>();

fiddle(myFoo);
```

函数执行的时候，存在无谓的原子性增加和减小操作，而且操作都使用了完整的内存屏障。使用普通指针可以避免无谓的原子操作。

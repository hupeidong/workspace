# unique_ptr

## 1. 独占式拥有

`unique_ptr` 实现独占式拥有或严格拥有概念。

```c++
#include <iostream>
#include <string>
#include <memory>
    
using namespace std;

int main() {
    unique_ptr<std::string> p1(new std::string("unique"));
    unique_ptr<std::string> p2;
    p1 = p2;
    
    return 0;
}

输出结果为：
Desktop % g++ main.cpp -o main -std=c++11
main.cpp:10:8: error: object of type 'unique_ptr<std::string>' 
(aka 'unique_ptr<basic_string<char, char_traits<char>, allocator<char> > >') 
cannot be assigned because its copy assignment operator is implicitly deleted
```

## 2. 临时右值

当程序试图将一个 `unique_ptr` 赋值给另一个时，如果源 `unique_ptr` 是个临时右值，编译器允许这么做。

```c++
#include <iostream>
#include <string>
#include <memory>

using namespace std;

int main() {
    unique_ptr<string> pu;
    pu = unique_ptr<string>(new string("You"));

    return 0;
}
```

## 3. move()

C++ 有一个标准库函数 `std::move()`，让你能够将一个 `unique_ptr` 赋给另一个。

```c++
#include <iostream>
#include <string>
#include <memory>

using namespace std;

int main() {
    unique_ptr<std::string> ps1, ps2;
    ps1 = unique_ptr<std::string>(new std::string("world"));
    ps2 = std::move(ps1);
    ps1 = unique_ptr<std::string>(new std::string("hello"));
    cout << "ps1: " << *ps1 << endl;
    cout << "ps2: " << *ps2 << endl;

    return 0;
}

输出结果为：
Desktop % ./main              
ps1: hello
ps2: world
```

## 4. release()

调用 `release()` 会切断 `unique_ptr` 和它原来管理的对象的联系。
`release()` 返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。

> `release()` 之后返回裸指针。

```c++
#include <iostream>
#include <string>
#include <memory>

using namespace std;

int main() {
    unique_ptr<std::string> ps1, ps2;
    ps1 = unique_ptr<std::string>(new std::string("hello"));
    // ps2 = ps1.release(); // 编译不通过
    std::string * ptr = ps1.release();
    cout << "ps1: " << ps1 << endl;
    cout << "ptr: " << *ptr << endl;

    return 0;
}

输出结果为：
hupeidong@ZBMac-C02F31WYM Desktop % ./main              
ps1: 0x0
ptr: hello
```
